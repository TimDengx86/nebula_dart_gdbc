// ignore_for_file: slash_for_doc_comments, unnecessary_new, non_constant_identifier_names, constant_identifier_names, unnecessary_this, empty_constructor_bodies, annotate_overrides, unnecessary_null_comparison, prefer_collection_literals, no_leading_underscores_for_local_identifiers, unused_import, unnecessary_import, prefer_interpolation_to_compose_strings, camel_case_types, prefer_generic_function_type_aliases, avoid_init_to_null, prefer_final_fields, unused_field

/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library nebula_meta.src.meta_service;

import 'dart:async';
import 'dart:typed_data' show Uint8List;
import 'package:fbthrift/fbthrift.dart';
import 'package:nebula_dart_gdbc/gen/nebula_meta/nebula_meta.dart';
import 'package:nebula_dart_gdbc/gen/nebula/nebula.dart' as t_nebula;

abstract class MetaService {
  Future<ExecResp> createSpace(CreateSpaceReq? req);

  Future<ExecResp> dropSpace(DropSpaceReq? req);

  Future<ExecResp> clearSpace(ClearSpaceReq? req);

  Future<GetSpaceResp> getSpace(GetSpaceReq? req);

  Future<ListSpacesResp> listSpaces(ListSpacesReq? req);

  Future<ExecResp> alterSpace(AlterSpaceReq? req);

  Future<ExecResp> createSpaceAs(CreateSpaceAsReq? req);

  Future<ExecResp> createTag(CreateTagReq? req);

  Future<ExecResp> alterTag(AlterTagReq? req);

  Future<ExecResp> dropTag(DropTagReq? req);

  Future<GetTagResp> getTag(GetTagReq? req);

  Future<ListTagsResp> listTags(ListTagsReq? req);

  Future<ExecResp> createEdge(CreateEdgeReq? req);

  Future<ExecResp> alterEdge(AlterEdgeReq? req);

  Future<ExecResp> dropEdge(DropEdgeReq? req);

  Future<GetEdgeResp> getEdge(GetEdgeReq? req);

  Future<ListEdgesResp> listEdges(ListEdgesReq? req);

  Future<ExecResp> addHosts(AddHostsReq? req);

  Future<ExecResp> addHostsIntoZone(AddHostsIntoZoneReq? req);

  Future<ExecResp> dropHosts(DropHostsReq? req);

  Future<ListHostsResp> listHosts(ListHostsReq? req);

  Future<GetPartsAllocResp> getPartsAlloc(GetPartsAllocReq? req);

  Future<ListPartsResp> listParts(ListPartsReq? req);

  Future<GetWorkerIdResp> getWorkerId(GetWorkerIdReq? req);

  Future<ExecResp> createTagIndex(CreateTagIndexReq? req);

  Future<ExecResp> dropTagIndex(DropTagIndexReq? req);

  Future<GetTagIndexResp> getTagIndex(GetTagIndexReq? req);

  Future<ListTagIndexesResp> listTagIndexes(ListTagIndexesReq? req);

  Future<ExecResp> rebuildTagIndex(RebuildIndexReq? req);

  Future<ListIndexStatusResp> listTagIndexStatus(ListIndexStatusReq? req);

  Future<ExecResp> createEdgeIndex(CreateEdgeIndexReq? req);

  Future<ExecResp> dropEdgeIndex(DropEdgeIndexReq? req);

  Future<GetEdgeIndexResp> getEdgeIndex(GetEdgeIndexReq? req);

  Future<ListEdgeIndexesResp> listEdgeIndexes(ListEdgeIndexesReq? req);

  Future<ExecResp> rebuildEdgeIndex(RebuildIndexReq? req);

  Future<ListIndexStatusResp> listEdgeIndexStatus(ListIndexStatusReq? req);

  Future<ExecResp> createUser(CreateUserReq? req);

  Future<ExecResp> dropUser(DropUserReq? req);

  Future<ExecResp> alterUser(AlterUserReq? req);

  Future<ExecResp> grantRole(GrantRoleReq? req);

  Future<ExecResp> revokeRole(RevokeRoleReq? req);

  Future<ListUsersResp> listUsers(ListUsersReq? req);

  Future<ListRolesResp> listRoles(ListRolesReq? req);

  Future<ListRolesResp> getUserRoles(GetUserRolesReq? req);

  Future<ExecResp> changePassword(ChangePasswordReq? req);

  Future<HBResp> heartBeat(HBReq? req);

  Future<AgentHBResp> agentHeartbeat(AgentHBReq? req);

  Future<ExecResp> regConfig(RegConfigReq? req);

  Future<GetConfigResp> getConfig(GetConfigReq? req);

  Future<ExecResp> setConfig(SetConfigReq? req);

  Future<ListConfigsResp> listConfigs(ListConfigsReq? req);

  Future<ExecResp> createSnapshot(CreateSnapshotReq? req);

  Future<ExecResp> dropSnapshot(DropSnapshotReq? req);

  Future<ListSnapshotsResp> listSnapshots(ListSnapshotsReq? req);

  Future<AdminJobResp> runAdminJob(AdminJobReq? req);

  Future<ExecResp> mergeZone(MergeZoneReq? req);

  Future<ExecResp> dropZone(DropZoneReq? req);

  Future<ExecResp> divideZone(DivideZoneReq? req);

  Future<ExecResp> renameZone(RenameZoneReq? req);

  Future<GetZoneResp> getZone(GetZoneReq? req);

  Future<ListZonesResp> listZones(ListZonesReq? req);

  Future<ExecResp> addListener(AddListenerReq? req);

  Future<ExecResp> removeListener(RemoveListenerReq? req);

  Future<ListListenerResp> listListener(ListListenerReq? req);

  Future<GetStatsResp> getStats(GetStatsReq? req);

  Future<ExecResp> signInService(SignInServiceReq? req);

  Future<ExecResp> signOutService(SignOutServiceReq? req);

  Future<ListServiceClientsResp> listServiceClients(ListServiceClientsReq? req);

  Future<ExecResp> createFTIndex(CreateFTIndexReq? req);

  Future<ExecResp> dropFTIndex(DropFTIndexReq? req);

  Future<ListFTIndexesResp> listFTIndexes(ListFTIndexesReq? req);

  Future<CreateSessionResp> createSession(CreateSessionReq? req);

  Future<UpdateSessionsResp> updateSessions(UpdateSessionsReq? req);

  Future<ListSessionsResp> listSessions(ListSessionsReq? req);

  Future<GetSessionResp> getSession(GetSessionReq? req);

  Future<RemoveSessionResp> removeSession(RemoveSessionReq? req);

  Future<ExecResp> killQuery(KillQueryReq? req);

  Future<ExecResp> reportTaskFinish(ReportTaskReq? req);

  Future<CreateBackupResp> createBackup(CreateBackupReq? req);

  Future<RestoreMetaResp> restoreMeta(RestoreMetaReq? req);

  Future<ListClusterInfoResp> listCluster(ListClusterInfoReq? req);

  Future<GetMetaDirInfoResp> getMetaDirInfo(GetMetaDirInfoReq? req);

  Future<VerifyClientVersionResp> verifyClientVersion(
      VerifyClientVersionReq? req);

  Future<SaveGraphVersionResp> saveGraphVersion(SaveGraphVersionReq? req);

  Future<GetSegmentIdResp> getSegmentId(GetSegmentIdReq? req);
}

class MetaServiceClient implements MetaService {
  MetaServiceClient(TProtocol iprot, [TProtocol? oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  late TProtocol _iprot;

  TProtocol get iprot => _iprot;

  late TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => ++_seqid;

  Future<ExecResp> createSpace(CreateSpaceReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createSpace", TMessageType.CALL, nextSeqid()));
    createSpace_args args = new createSpace_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createSpace_result result = new createSpace_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createSpace failed: unknown result");
  }

  Future<ExecResp> dropSpace(DropSpaceReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropSpace", TMessageType.CALL, nextSeqid()));
    dropSpace_args args = new dropSpace_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropSpace_result result = new dropSpace_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropSpace failed: unknown result");
  }

  Future<ExecResp> clearSpace(ClearSpaceReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("clearSpace", TMessageType.CALL, nextSeqid()));
    clearSpace_args args = new clearSpace_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    clearSpace_result result = new clearSpace_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "clearSpace failed: unknown result");
  }

  Future<GetSpaceResp> getSpace(GetSpaceReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getSpace", TMessageType.CALL, nextSeqid()));
    getSpace_args args = new getSpace_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSpace_result result = new getSpace_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getSpace failed: unknown result");
  }

  Future<ListSpacesResp> listSpaces(ListSpacesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listSpaces", TMessageType.CALL, nextSeqid()));
    listSpaces_args args = new listSpaces_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listSpaces_result result = new listSpaces_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listSpaces failed: unknown result");
  }

  Future<ExecResp> alterSpace(AlterSpaceReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("alterSpace", TMessageType.CALL, nextSeqid()));
    alterSpace_args args = new alterSpace_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    alterSpace_result result = new alterSpace_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "alterSpace failed: unknown result");
  }

  Future<ExecResp> createSpaceAs(CreateSpaceAsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createSpaceAs", TMessageType.CALL, nextSeqid()));
    createSpaceAs_args args = new createSpaceAs_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createSpaceAs_result result = new createSpaceAs_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createSpaceAs failed: unknown result");
  }

  Future<ExecResp> createTag(CreateTagReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createTag", TMessageType.CALL, nextSeqid()));
    createTag_args args = new createTag_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createTag_result result = new createTag_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createTag failed: unknown result");
  }

  Future<ExecResp> alterTag(AlterTagReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("alterTag", TMessageType.CALL, nextSeqid()));
    alterTag_args args = new alterTag_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    alterTag_result result = new alterTag_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "alterTag failed: unknown result");
  }

  Future<ExecResp> dropTag(DropTagReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropTag", TMessageType.CALL, nextSeqid()));
    dropTag_args args = new dropTag_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropTag_result result = new dropTag_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(
        TApplicationErrorType.MISSING_RESULT, "dropTag failed: unknown result");
  }

  Future<GetTagResp> getTag(GetTagReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getTag", TMessageType.CALL, nextSeqid()));
    getTag_args args = new getTag_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getTag_result result = new getTag_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(
        TApplicationErrorType.MISSING_RESULT, "getTag failed: unknown result");
  }

  Future<ListTagsResp> listTags(ListTagsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listTags", TMessageType.CALL, nextSeqid()));
    listTags_args args = new listTags_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listTags_result result = new listTags_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listTags failed: unknown result");
  }

  Future<ExecResp> createEdge(CreateEdgeReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createEdge", TMessageType.CALL, nextSeqid()));
    createEdge_args args = new createEdge_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createEdge_result result = new createEdge_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createEdge failed: unknown result");
  }

  Future<ExecResp> alterEdge(AlterEdgeReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("alterEdge", TMessageType.CALL, nextSeqid()));
    alterEdge_args args = new alterEdge_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    alterEdge_result result = new alterEdge_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "alterEdge failed: unknown result");
  }

  Future<ExecResp> dropEdge(DropEdgeReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropEdge", TMessageType.CALL, nextSeqid()));
    dropEdge_args args = new dropEdge_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropEdge_result result = new dropEdge_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropEdge failed: unknown result");
  }

  Future<GetEdgeResp> getEdge(GetEdgeReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getEdge", TMessageType.CALL, nextSeqid()));
    getEdge_args args = new getEdge_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getEdge_result result = new getEdge_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(
        TApplicationErrorType.MISSING_RESULT, "getEdge failed: unknown result");
  }

  Future<ListEdgesResp> listEdges(ListEdgesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listEdges", TMessageType.CALL, nextSeqid()));
    listEdges_args args = new listEdges_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listEdges_result result = new listEdges_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listEdges failed: unknown result");
  }

  Future<ExecResp> addHosts(AddHostsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("addHosts", TMessageType.CALL, nextSeqid()));
    addHosts_args args = new addHosts_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    addHosts_result result = new addHosts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "addHosts failed: unknown result");
  }

  Future<ExecResp> addHostsIntoZone(AddHostsIntoZoneReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("addHostsIntoZone", TMessageType.CALL, nextSeqid()));
    addHostsIntoZone_args args = new addHostsIntoZone_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    addHostsIntoZone_result result = new addHostsIntoZone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "addHostsIntoZone failed: unknown result");
  }

  Future<ExecResp> dropHosts(DropHostsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropHosts", TMessageType.CALL, nextSeqid()));
    dropHosts_args args = new dropHosts_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropHosts_result result = new dropHosts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropHosts failed: unknown result");
  }

  Future<ListHostsResp> listHosts(ListHostsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listHosts", TMessageType.CALL, nextSeqid()));
    listHosts_args args = new listHosts_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listHosts_result result = new listHosts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listHosts failed: unknown result");
  }

  Future<GetPartsAllocResp> getPartsAlloc(GetPartsAllocReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getPartsAlloc", TMessageType.CALL, nextSeqid()));
    getPartsAlloc_args args = new getPartsAlloc_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getPartsAlloc_result result = new getPartsAlloc_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getPartsAlloc failed: unknown result");
  }

  Future<ListPartsResp> listParts(ListPartsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listParts", TMessageType.CALL, nextSeqid()));
    listParts_args args = new listParts_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listParts_result result = new listParts_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listParts failed: unknown result");
  }

  Future<GetWorkerIdResp> getWorkerId(GetWorkerIdReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getWorkerId", TMessageType.CALL, nextSeqid()));
    getWorkerId_args args = new getWorkerId_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getWorkerId_result result = new getWorkerId_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getWorkerId failed: unknown result");
  }

  Future<ExecResp> createTagIndex(CreateTagIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createTagIndex", TMessageType.CALL, nextSeqid()));
    createTagIndex_args args = new createTagIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createTagIndex_result result = new createTagIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createTagIndex failed: unknown result");
  }

  Future<ExecResp> dropTagIndex(DropTagIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropTagIndex", TMessageType.CALL, nextSeqid()));
    dropTagIndex_args args = new dropTagIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropTagIndex_result result = new dropTagIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropTagIndex failed: unknown result");
  }

  Future<GetTagIndexResp> getTagIndex(GetTagIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getTagIndex", TMessageType.CALL, nextSeqid()));
    getTagIndex_args args = new getTagIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getTagIndex_result result = new getTagIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getTagIndex failed: unknown result");
  }

  Future<ListTagIndexesResp> listTagIndexes(ListTagIndexesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listTagIndexes", TMessageType.CALL, nextSeqid()));
    listTagIndexes_args args = new listTagIndexes_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listTagIndexes_result result = new listTagIndexes_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listTagIndexes failed: unknown result");
  }

  Future<ExecResp> rebuildTagIndex(RebuildIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("rebuildTagIndex", TMessageType.CALL, nextSeqid()));
    rebuildTagIndex_args args = new rebuildTagIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    rebuildTagIndex_result result = new rebuildTagIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "rebuildTagIndex failed: unknown result");
  }

  Future<ListIndexStatusResp> listTagIndexStatus(
      ListIndexStatusReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listTagIndexStatus", TMessageType.CALL, nextSeqid()));
    listTagIndexStatus_args args = new listTagIndexStatus_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listTagIndexStatus_result result = new listTagIndexStatus_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listTagIndexStatus failed: unknown result");
  }

  Future<ExecResp> createEdgeIndex(CreateEdgeIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createEdgeIndex", TMessageType.CALL, nextSeqid()));
    createEdgeIndex_args args = new createEdgeIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createEdgeIndex_result result = new createEdgeIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createEdgeIndex failed: unknown result");
  }

  Future<ExecResp> dropEdgeIndex(DropEdgeIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropEdgeIndex", TMessageType.CALL, nextSeqid()));
    dropEdgeIndex_args args = new dropEdgeIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropEdgeIndex_result result = new dropEdgeIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropEdgeIndex failed: unknown result");
  }

  Future<GetEdgeIndexResp> getEdgeIndex(GetEdgeIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getEdgeIndex", TMessageType.CALL, nextSeqid()));
    getEdgeIndex_args args = new getEdgeIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getEdgeIndex_result result = new getEdgeIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getEdgeIndex failed: unknown result");
  }

  Future<ListEdgeIndexesResp> listEdgeIndexes(ListEdgeIndexesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listEdgeIndexes", TMessageType.CALL, nextSeqid()));
    listEdgeIndexes_args args = new listEdgeIndexes_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listEdgeIndexes_result result = new listEdgeIndexes_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listEdgeIndexes failed: unknown result");
  }

  Future<ExecResp> rebuildEdgeIndex(RebuildIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("rebuildEdgeIndex", TMessageType.CALL, nextSeqid()));
    rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "rebuildEdgeIndex failed: unknown result");
  }

  Future<ListIndexStatusResp> listEdgeIndexStatus(
      ListIndexStatusReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listEdgeIndexStatus", TMessageType.CALL, nextSeqid()));
    listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listEdgeIndexStatus failed: unknown result");
  }

  Future<ExecResp> createUser(CreateUserReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createUser", TMessageType.CALL, nextSeqid()));
    createUser_args args = new createUser_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createUser_result result = new createUser_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createUser failed: unknown result");
  }

  Future<ExecResp> dropUser(DropUserReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropUser", TMessageType.CALL, nextSeqid()));
    dropUser_args args = new dropUser_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropUser_result result = new dropUser_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropUser failed: unknown result");
  }

  Future<ExecResp> alterUser(AlterUserReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("alterUser", TMessageType.CALL, nextSeqid()));
    alterUser_args args = new alterUser_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    alterUser_result result = new alterUser_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "alterUser failed: unknown result");
  }

  Future<ExecResp> grantRole(GrantRoleReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("grantRole", TMessageType.CALL, nextSeqid()));
    grantRole_args args = new grantRole_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    grantRole_result result = new grantRole_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "grantRole failed: unknown result");
  }

  Future<ExecResp> revokeRole(RevokeRoleReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("revokeRole", TMessageType.CALL, nextSeqid()));
    revokeRole_args args = new revokeRole_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    revokeRole_result result = new revokeRole_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "revokeRole failed: unknown result");
  }

  Future<ListUsersResp> listUsers(ListUsersReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listUsers", TMessageType.CALL, nextSeqid()));
    listUsers_args args = new listUsers_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listUsers_result result = new listUsers_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listUsers failed: unknown result");
  }

  Future<ListRolesResp> listRoles(ListRolesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listRoles", TMessageType.CALL, nextSeqid()));
    listRoles_args args = new listRoles_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listRoles_result result = new listRoles_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listRoles failed: unknown result");
  }

  Future<ListRolesResp> getUserRoles(GetUserRolesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getUserRoles", TMessageType.CALL, nextSeqid()));
    getUserRoles_args args = new getUserRoles_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getUserRoles_result result = new getUserRoles_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getUserRoles failed: unknown result");
  }

  Future<ExecResp> changePassword(ChangePasswordReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("changePassword", TMessageType.CALL, nextSeqid()));
    changePassword_args args = new changePassword_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    changePassword_result result = new changePassword_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "changePassword failed: unknown result");
  }

  Future<HBResp> heartBeat(HBReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("heartBeat", TMessageType.CALL, nextSeqid()));
    heartBeat_args args = new heartBeat_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    heartBeat_result result = new heartBeat_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "heartBeat failed: unknown result");
  }

  Future<AgentHBResp> agentHeartbeat(AgentHBReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("agentHeartbeat", TMessageType.CALL, nextSeqid()));
    agentHeartbeat_args args = new agentHeartbeat_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    agentHeartbeat_result result = new agentHeartbeat_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "agentHeartbeat failed: unknown result");
  }

  Future<ExecResp> regConfig(RegConfigReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("regConfig", TMessageType.CALL, nextSeqid()));
    regConfig_args args = new regConfig_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    regConfig_result result = new regConfig_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "regConfig failed: unknown result");
  }

  Future<GetConfigResp> getConfig(GetConfigReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getConfig", TMessageType.CALL, nextSeqid()));
    getConfig_args args = new getConfig_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getConfig_result result = new getConfig_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getConfig failed: unknown result");
  }

  Future<ExecResp> setConfig(SetConfigReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("setConfig", TMessageType.CALL, nextSeqid()));
    setConfig_args args = new setConfig_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    setConfig_result result = new setConfig_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "setConfig failed: unknown result");
  }

  Future<ListConfigsResp> listConfigs(ListConfigsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listConfigs", TMessageType.CALL, nextSeqid()));
    listConfigs_args args = new listConfigs_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listConfigs_result result = new listConfigs_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listConfigs failed: unknown result");
  }

  Future<ExecResp> createSnapshot(CreateSnapshotReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createSnapshot", TMessageType.CALL, nextSeqid()));
    createSnapshot_args args = new createSnapshot_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createSnapshot_result result = new createSnapshot_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createSnapshot failed: unknown result");
  }

  Future<ExecResp> dropSnapshot(DropSnapshotReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropSnapshot", TMessageType.CALL, nextSeqid()));
    dropSnapshot_args args = new dropSnapshot_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropSnapshot_result result = new dropSnapshot_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropSnapshot failed: unknown result");
  }

  Future<ListSnapshotsResp> listSnapshots(ListSnapshotsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listSnapshots", TMessageType.CALL, nextSeqid()));
    listSnapshots_args args = new listSnapshots_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listSnapshots_result result = new listSnapshots_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listSnapshots failed: unknown result");
  }

  Future<AdminJobResp> runAdminJob(AdminJobReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("runAdminJob", TMessageType.CALL, nextSeqid()));
    runAdminJob_args args = new runAdminJob_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    runAdminJob_result result = new runAdminJob_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "runAdminJob failed: unknown result");
  }

  Future<ExecResp> mergeZone(MergeZoneReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("mergeZone", TMessageType.CALL, nextSeqid()));
    mergeZone_args args = new mergeZone_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    mergeZone_result result = new mergeZone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "mergeZone failed: unknown result");
  }

  Future<ExecResp> dropZone(DropZoneReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropZone", TMessageType.CALL, nextSeqid()));
    dropZone_args args = new dropZone_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropZone_result result = new dropZone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropZone failed: unknown result");
  }

  Future<ExecResp> divideZone(DivideZoneReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("divideZone", TMessageType.CALL, nextSeqid()));
    divideZone_args args = new divideZone_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    divideZone_result result = new divideZone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "divideZone failed: unknown result");
  }

  Future<ExecResp> renameZone(RenameZoneReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("renameZone", TMessageType.CALL, nextSeqid()));
    renameZone_args args = new renameZone_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    renameZone_result result = new renameZone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "renameZone failed: unknown result");
  }

  Future<GetZoneResp> getZone(GetZoneReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getZone", TMessageType.CALL, nextSeqid()));
    getZone_args args = new getZone_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getZone_result result = new getZone_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(
        TApplicationErrorType.MISSING_RESULT, "getZone failed: unknown result");
  }

  Future<ListZonesResp> listZones(ListZonesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listZones", TMessageType.CALL, nextSeqid()));
    listZones_args args = new listZones_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listZones_result result = new listZones_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listZones failed: unknown result");
  }

  Future<ExecResp> addListener(AddListenerReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("addListener", TMessageType.CALL, nextSeqid()));
    addListener_args args = new addListener_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    addListener_result result = new addListener_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "addListener failed: unknown result");
  }

  Future<ExecResp> removeListener(RemoveListenerReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("removeListener", TMessageType.CALL, nextSeqid()));
    removeListener_args args = new removeListener_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeListener_result result = new removeListener_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "removeListener failed: unknown result");
  }

  Future<ListListenerResp> listListener(ListListenerReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listListener", TMessageType.CALL, nextSeqid()));
    listListener_args args = new listListener_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listListener_result result = new listListener_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listListener failed: unknown result");
  }

  Future<GetStatsResp> getStats(GetStatsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getStats", TMessageType.CALL, nextSeqid()));
    getStats_args args = new getStats_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getStats_result result = new getStats_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getStats failed: unknown result");
  }

  Future<ExecResp> signInService(SignInServiceReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("signInService", TMessageType.CALL, nextSeqid()));
    signInService_args args = new signInService_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    signInService_result result = new signInService_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "signInService failed: unknown result");
  }

  Future<ExecResp> signOutService(SignOutServiceReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("signOutService", TMessageType.CALL, nextSeqid()));
    signOutService_args args = new signOutService_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    signOutService_result result = new signOutService_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "signOutService failed: unknown result");
  }

  Future<ListServiceClientsResp> listServiceClients(
      ListServiceClientsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listServiceClients", TMessageType.CALL, nextSeqid()));
    listServiceClients_args args = new listServiceClients_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listServiceClients_result result = new listServiceClients_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listServiceClients failed: unknown result");
  }

  Future<ExecResp> createFTIndex(CreateFTIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createFTIndex", TMessageType.CALL, nextSeqid()));
    createFTIndex_args args = new createFTIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createFTIndex_result result = new createFTIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createFTIndex failed: unknown result");
  }

  Future<ExecResp> dropFTIndex(DropFTIndexReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("dropFTIndex", TMessageType.CALL, nextSeqid()));
    dropFTIndex_args args = new dropFTIndex_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    dropFTIndex_result result = new dropFTIndex_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "dropFTIndex failed: unknown result");
  }

  Future<ListFTIndexesResp> listFTIndexes(ListFTIndexesReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listFTIndexes", TMessageType.CALL, nextSeqid()));
    listFTIndexes_args args = new listFTIndexes_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listFTIndexes_result result = new listFTIndexes_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listFTIndexes failed: unknown result");
  }

  Future<CreateSessionResp> createSession(CreateSessionReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createSession", TMessageType.CALL, nextSeqid()));
    createSession_args args = new createSession_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createSession_result result = new createSession_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createSession failed: unknown result");
  }

  Future<UpdateSessionsResp> updateSessions(UpdateSessionsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("updateSessions", TMessageType.CALL, nextSeqid()));
    updateSessions_args args = new updateSessions_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    updateSessions_result result = new updateSessions_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "updateSessions failed: unknown result");
  }

  Future<ListSessionsResp> listSessions(ListSessionsReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listSessions", TMessageType.CALL, nextSeqid()));
    listSessions_args args = new listSessions_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listSessions_result result = new listSessions_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listSessions failed: unknown result");
  }

  Future<GetSessionResp> getSession(GetSessionReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getSession", TMessageType.CALL, nextSeqid()));
    getSession_args args = new getSession_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSession_result result = new getSession_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getSession failed: unknown result");
  }

  Future<RemoveSessionResp> removeSession(RemoveSessionReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("removeSession", TMessageType.CALL, nextSeqid()));
    removeSession_args args = new removeSession_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    removeSession_result result = new removeSession_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "removeSession failed: unknown result");
  }

  Future<ExecResp> killQuery(KillQueryReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("killQuery", TMessageType.CALL, nextSeqid()));
    killQuery_args args = new killQuery_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    killQuery_result result = new killQuery_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "killQuery failed: unknown result");
  }

  Future<ExecResp> reportTaskFinish(ReportTaskReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("reportTaskFinish", TMessageType.CALL, nextSeqid()));
    reportTaskFinish_args args = new reportTaskFinish_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    reportTaskFinish_result result = new reportTaskFinish_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "reportTaskFinish failed: unknown result");
  }

  Future<CreateBackupResp> createBackup(CreateBackupReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("createBackup", TMessageType.CALL, nextSeqid()));
    createBackup_args args = new createBackup_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    createBackup_result result = new createBackup_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "createBackup failed: unknown result");
  }

  Future<RestoreMetaResp> restoreMeta(RestoreMetaReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("restoreMeta", TMessageType.CALL, nextSeqid()));
    restoreMeta_args args = new restoreMeta_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    restoreMeta_result result = new restoreMeta_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "restoreMeta failed: unknown result");
  }

  Future<ListClusterInfoResp> listCluster(ListClusterInfoReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("listCluster", TMessageType.CALL, nextSeqid()));
    listCluster_args args = new listCluster_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    listCluster_result result = new listCluster_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "listCluster failed: unknown result");
  }

  Future<GetMetaDirInfoResp> getMetaDirInfo(GetMetaDirInfoReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getMetaDirInfo", TMessageType.CALL, nextSeqid()));
    getMetaDirInfo_args args = new getMetaDirInfo_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getMetaDirInfo_result result = new getMetaDirInfo_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getMetaDirInfo failed: unknown result");
  }

  Future<VerifyClientVersionResp> verifyClientVersion(
      VerifyClientVersionReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("verifyClientVersion", TMessageType.CALL, nextSeqid()));
    verifyClientVersion_args args = new verifyClientVersion_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    verifyClientVersion_result result = new verifyClientVersion_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "verifyClientVersion failed: unknown result");
  }

  Future<SaveGraphVersionResp> saveGraphVersion(
      SaveGraphVersionReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("saveGraphVersion", TMessageType.CALL, nextSeqid()));
    saveGraphVersion_args args = new saveGraphVersion_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    saveGraphVersion_result result = new saveGraphVersion_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "saveGraphVersion failed: unknown result");
  }

  Future<GetSegmentIdResp> getSegmentId(GetSegmentIdReq? req) async {
    oprot.writeMessageBegin(
        new TMessage("getSegmentId", TMessageType.CALL, nextSeqid()));
    getSegmentId_args args = new getSegmentId_args();
    args.req = req;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.trans_.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    getSegmentId_result result = new getSegmentId_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success!;
    }

    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT,
        "getSegmentId failed: unknown result");
  }
}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class MetaServiceProcessor implements TProcessor {
  MetaServiceProcessor(MetaService iface) {
    iface_ = iface;
    PROCESS_MAP["createSpace"] = createSpace;
    PROCESS_MAP["dropSpace"] = dropSpace;
    PROCESS_MAP["clearSpace"] = clearSpace;
    PROCESS_MAP["getSpace"] = getSpace;
    PROCESS_MAP["listSpaces"] = listSpaces;
    PROCESS_MAP["alterSpace"] = alterSpace;
    PROCESS_MAP["createSpaceAs"] = createSpaceAs;
    PROCESS_MAP["createTag"] = createTag;
    PROCESS_MAP["alterTag"] = alterTag;
    PROCESS_MAP["dropTag"] = dropTag;
    PROCESS_MAP["getTag"] = getTag;
    PROCESS_MAP["listTags"] = listTags;
    PROCESS_MAP["createEdge"] = createEdge;
    PROCESS_MAP["alterEdge"] = alterEdge;
    PROCESS_MAP["dropEdge"] = dropEdge;
    PROCESS_MAP["getEdge"] = getEdge;
    PROCESS_MAP["listEdges"] = listEdges;
    PROCESS_MAP["addHosts"] = addHosts;
    PROCESS_MAP["addHostsIntoZone"] = addHostsIntoZone;
    PROCESS_MAP["dropHosts"] = dropHosts;
    PROCESS_MAP["listHosts"] = listHosts;
    PROCESS_MAP["getPartsAlloc"] = getPartsAlloc;
    PROCESS_MAP["listParts"] = listParts;
    PROCESS_MAP["getWorkerId"] = getWorkerId;
    PROCESS_MAP["createTagIndex"] = createTagIndex;
    PROCESS_MAP["dropTagIndex"] = dropTagIndex;
    PROCESS_MAP["getTagIndex"] = getTagIndex;
    PROCESS_MAP["listTagIndexes"] = listTagIndexes;
    PROCESS_MAP["rebuildTagIndex"] = rebuildTagIndex;
    PROCESS_MAP["listTagIndexStatus"] = listTagIndexStatus;
    PROCESS_MAP["createEdgeIndex"] = createEdgeIndex;
    PROCESS_MAP["dropEdgeIndex"] = dropEdgeIndex;
    PROCESS_MAP["getEdgeIndex"] = getEdgeIndex;
    PROCESS_MAP["listEdgeIndexes"] = listEdgeIndexes;
    PROCESS_MAP["rebuildEdgeIndex"] = rebuildEdgeIndex;
    PROCESS_MAP["listEdgeIndexStatus"] = listEdgeIndexStatus;
    PROCESS_MAP["createUser"] = createUser;
    PROCESS_MAP["dropUser"] = dropUser;
    PROCESS_MAP["alterUser"] = alterUser;
    PROCESS_MAP["grantRole"] = grantRole;
    PROCESS_MAP["revokeRole"] = revokeRole;
    PROCESS_MAP["listUsers"] = listUsers;
    PROCESS_MAP["listRoles"] = listRoles;
    PROCESS_MAP["getUserRoles"] = getUserRoles;
    PROCESS_MAP["changePassword"] = changePassword;
    PROCESS_MAP["heartBeat"] = heartBeat;
    PROCESS_MAP["agentHeartbeat"] = agentHeartbeat;
    PROCESS_MAP["regConfig"] = regConfig;
    PROCESS_MAP["getConfig"] = getConfig;
    PROCESS_MAP["setConfig"] = setConfig;
    PROCESS_MAP["listConfigs"] = listConfigs;
    PROCESS_MAP["createSnapshot"] = createSnapshot;
    PROCESS_MAP["dropSnapshot"] = dropSnapshot;
    PROCESS_MAP["listSnapshots"] = listSnapshots;
    PROCESS_MAP["runAdminJob"] = runAdminJob;
    PROCESS_MAP["mergeZone"] = mergeZone;
    PROCESS_MAP["dropZone"] = dropZone;
    PROCESS_MAP["divideZone"] = divideZone;
    PROCESS_MAP["renameZone"] = renameZone;
    PROCESS_MAP["getZone"] = getZone;
    PROCESS_MAP["listZones"] = listZones;
    PROCESS_MAP["addListener"] = addListener;
    PROCESS_MAP["removeListener"] = removeListener;
    PROCESS_MAP["listListener"] = listListener;
    PROCESS_MAP["getStats"] = getStats;
    PROCESS_MAP["signInService"] = signInService;
    PROCESS_MAP["signOutService"] = signOutService;
    PROCESS_MAP["listServiceClients"] = listServiceClients;
    PROCESS_MAP["createFTIndex"] = createFTIndex;
    PROCESS_MAP["dropFTIndex"] = dropFTIndex;
    PROCESS_MAP["listFTIndexes"] = listFTIndexes;
    PROCESS_MAP["createSession"] = createSession;
    PROCESS_MAP["updateSessions"] = updateSessions;
    PROCESS_MAP["listSessions"] = listSessions;
    PROCESS_MAP["getSession"] = getSession;
    PROCESS_MAP["removeSession"] = removeSession;
    PROCESS_MAP["killQuery"] = killQuery;
    PROCESS_MAP["reportTaskFinish"] = reportTaskFinish;
    PROCESS_MAP["createBackup"] = createBackup;
    PROCESS_MAP["restoreMeta"] = restoreMeta;
    PROCESS_MAP["listCluster"] = listCluster;
    PROCESS_MAP["getMetaDirInfo"] = getMetaDirInfo;
    PROCESS_MAP["verifyClientVersion"] = verifyClientVersion;
    PROCESS_MAP["saveGraphVersion"] = saveGraphVersion;
    PROCESS_MAP["getSegmentId"] = getSegmentId;
  }

  late MetaService iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction? fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(
          TApplicationErrorType.UNKNOWN_METHOD,
          "Invalid method name: '" + msg.name + "'");
      oprot.writeMessageBegin(
          new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.trans_.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  createSpace(int seqid, TProtocol iprot, TProtocol oprot) async {
    createSpace_args args = new createSpace_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createSpace_result result = new createSpace_result();
    result.success = await iface_.createSpace(args.req!);
    oprot.writeMessageBegin(
        new TMessage("createSpace", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropSpace(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropSpace_args args = new dropSpace_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropSpace_result result = new dropSpace_result();
    result.success = await iface_.dropSpace(args.req);
    oprot.writeMessageBegin(
        new TMessage("dropSpace", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  clearSpace(int seqid, TProtocol iprot, TProtocol oprot) async {
    clearSpace_args args = new clearSpace_args();
    args.read(iprot);
    iprot.readMessageEnd();
    clearSpace_result result = new clearSpace_result();
    result.success = await iface_.clearSpace(args.req);
    oprot.writeMessageBegin(
        new TMessage("clearSpace", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getSpace(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSpace_args args = new getSpace_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSpace_result result = new getSpace_result();
    result.success = await iface_.getSpace(args.req);
    oprot
        .writeMessageBegin(new TMessage("getSpace", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listSpaces(int seqid, TProtocol iprot, TProtocol oprot) async {
    listSpaces_args args = new listSpaces_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listSpaces_result result = new listSpaces_result();
    result.success = await iface_.listSpaces(args.req);
    oprot.writeMessageBegin(
        new TMessage("listSpaces", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  alterSpace(int seqid, TProtocol iprot, TProtocol oprot) async {
    alterSpace_args args = new alterSpace_args();
    args.read(iprot);
    iprot.readMessageEnd();
    alterSpace_result result = new alterSpace_result();
    result.success = await iface_.alterSpace(args.req);
    oprot.writeMessageBegin(
        new TMessage("alterSpace", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createSpaceAs(int seqid, TProtocol iprot, TProtocol oprot) async {
    createSpaceAs_args args = new createSpaceAs_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createSpaceAs_result result = new createSpaceAs_result();
    result.success = await iface_.createSpaceAs(args.req);
    oprot.writeMessageBegin(
        new TMessage("createSpaceAs", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createTag(int seqid, TProtocol iprot, TProtocol oprot) async {
    createTag_args args = new createTag_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createTag_result result = new createTag_result();
    result.success = await iface_.createTag(args.req);
    oprot.writeMessageBegin(
        new TMessage("createTag", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  alterTag(int seqid, TProtocol iprot, TProtocol oprot) async {
    alterTag_args args = new alterTag_args();
    args.read(iprot);
    iprot.readMessageEnd();
    alterTag_result result = new alterTag_result();
    result.success = await iface_.alterTag(args.req);
    oprot
        .writeMessageBegin(new TMessage("alterTag", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropTag(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropTag_args args = new dropTag_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropTag_result result = new dropTag_result();
    result.success = await iface_.dropTag(args.req);
    oprot.writeMessageBegin(new TMessage("dropTag", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getTag(int seqid, TProtocol iprot, TProtocol oprot) async {
    getTag_args args = new getTag_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getTag_result result = new getTag_result();
    result.success = await iface_.getTag(args.req);
    oprot.writeMessageBegin(new TMessage("getTag", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listTags(int seqid, TProtocol iprot, TProtocol oprot) async {
    listTags_args args = new listTags_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listTags_result result = new listTags_result();
    result.success = await iface_.listTags(args.req);
    oprot
        .writeMessageBegin(new TMessage("listTags", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createEdge(int seqid, TProtocol iprot, TProtocol oprot) async {
    createEdge_args args = new createEdge_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createEdge_result result = new createEdge_result();
    result.success = await iface_.createEdge(args.req);
    oprot.writeMessageBegin(
        new TMessage("createEdge", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  alterEdge(int seqid, TProtocol iprot, TProtocol oprot) async {
    alterEdge_args args = new alterEdge_args();
    args.read(iprot);
    iprot.readMessageEnd();
    alterEdge_result result = new alterEdge_result();
    result.success = await iface_.alterEdge(args.req);
    oprot.writeMessageBegin(
        new TMessage("alterEdge", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropEdge(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropEdge_args args = new dropEdge_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropEdge_result result = new dropEdge_result();
    result.success = await iface_.dropEdge(args.req);
    oprot
        .writeMessageBegin(new TMessage("dropEdge", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getEdge(int seqid, TProtocol iprot, TProtocol oprot) async {
    getEdge_args args = new getEdge_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getEdge_result result = new getEdge_result();
    result.success = await iface_.getEdge(args.req);
    oprot.writeMessageBegin(new TMessage("getEdge", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listEdges(int seqid, TProtocol iprot, TProtocol oprot) async {
    listEdges_args args = new listEdges_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listEdges_result result = new listEdges_result();
    result.success = await iface_.listEdges(args.req);
    oprot.writeMessageBegin(
        new TMessage("listEdges", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  addHosts(int seqid, TProtocol iprot, TProtocol oprot) async {
    addHosts_args args = new addHosts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    addHosts_result result = new addHosts_result();
    result.success = await iface_.addHosts(args.req);
    oprot
        .writeMessageBegin(new TMessage("addHosts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  addHostsIntoZone(int seqid, TProtocol iprot, TProtocol oprot) async {
    addHostsIntoZone_args args = new addHostsIntoZone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    addHostsIntoZone_result result = new addHostsIntoZone_result();
    result.success = await iface_.addHostsIntoZone(args.req);
    oprot.writeMessageBegin(
        new TMessage("addHostsIntoZone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropHosts(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropHosts_args args = new dropHosts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropHosts_result result = new dropHosts_result();
    result.success = await iface_.dropHosts(args.req);
    oprot.writeMessageBegin(
        new TMessage("dropHosts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listHosts(int seqid, TProtocol iprot, TProtocol oprot) async {
    listHosts_args args = new listHosts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listHosts_result result = new listHosts_result();
    result.success = await iface_.listHosts(args.req);
    oprot.writeMessageBegin(
        new TMessage("listHosts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getPartsAlloc(int seqid, TProtocol iprot, TProtocol oprot) async {
    getPartsAlloc_args args = new getPartsAlloc_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getPartsAlloc_result result = new getPartsAlloc_result();
    result.success = await iface_.getPartsAlloc(args.req);
    oprot.writeMessageBegin(
        new TMessage("getPartsAlloc", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listParts(int seqid, TProtocol iprot, TProtocol oprot) async {
    listParts_args args = new listParts_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listParts_result result = new listParts_result();
    result.success = await iface_.listParts(args.req);
    oprot.writeMessageBegin(
        new TMessage("listParts", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getWorkerId(int seqid, TProtocol iprot, TProtocol oprot) async {
    getWorkerId_args args = new getWorkerId_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getWorkerId_result result = new getWorkerId_result();
    result.success = await iface_.getWorkerId(args.req);
    oprot.writeMessageBegin(
        new TMessage("getWorkerId", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createTagIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    createTagIndex_args args = new createTagIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createTagIndex_result result = new createTagIndex_result();
    result.success = await iface_.createTagIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("createTagIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropTagIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropTagIndex_args args = new dropTagIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropTagIndex_result result = new dropTagIndex_result();
    result.success = await iface_.dropTagIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("dropTagIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getTagIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    getTagIndex_args args = new getTagIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getTagIndex_result result = new getTagIndex_result();
    result.success = await iface_.getTagIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("getTagIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listTagIndexes(int seqid, TProtocol iprot, TProtocol oprot) async {
    listTagIndexes_args args = new listTagIndexes_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listTagIndexes_result result = new listTagIndexes_result();
    result.success = await iface_.listTagIndexes(args.req);
    oprot.writeMessageBegin(
        new TMessage("listTagIndexes", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  rebuildTagIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    rebuildTagIndex_args args = new rebuildTagIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    rebuildTagIndex_result result = new rebuildTagIndex_result();
    result.success = await iface_.rebuildTagIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("rebuildTagIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listTagIndexStatus(int seqid, TProtocol iprot, TProtocol oprot) async {
    listTagIndexStatus_args args = new listTagIndexStatus_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listTagIndexStatus_result result = new listTagIndexStatus_result();
    result.success = await iface_.listTagIndexStatus(args.req);
    oprot.writeMessageBegin(
        new TMessage("listTagIndexStatus", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createEdgeIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    createEdgeIndex_args args = new createEdgeIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createEdgeIndex_result result = new createEdgeIndex_result();
    result.success = await iface_.createEdgeIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("createEdgeIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropEdgeIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropEdgeIndex_args args = new dropEdgeIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropEdgeIndex_result result = new dropEdgeIndex_result();
    result.success = await iface_.dropEdgeIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("dropEdgeIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getEdgeIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    getEdgeIndex_args args = new getEdgeIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getEdgeIndex_result result = new getEdgeIndex_result();
    result.success = await iface_.getEdgeIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("getEdgeIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listEdgeIndexes(int seqid, TProtocol iprot, TProtocol oprot) async {
    listEdgeIndexes_args args = new listEdgeIndexes_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listEdgeIndexes_result result = new listEdgeIndexes_result();
    result.success = await iface_.listEdgeIndexes(args.req);
    oprot.writeMessageBegin(
        new TMessage("listEdgeIndexes", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  rebuildEdgeIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    rebuildEdgeIndex_args args = new rebuildEdgeIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    rebuildEdgeIndex_result result = new rebuildEdgeIndex_result();
    result.success = await iface_.rebuildEdgeIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("rebuildEdgeIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listEdgeIndexStatus(int seqid, TProtocol iprot, TProtocol oprot) async {
    listEdgeIndexStatus_args args = new listEdgeIndexStatus_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listEdgeIndexStatus_result result = new listEdgeIndexStatus_result();
    result.success = await iface_.listEdgeIndexStatus(args.req);
    oprot.writeMessageBegin(
        new TMessage("listEdgeIndexStatus", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createUser(int seqid, TProtocol iprot, TProtocol oprot) async {
    createUser_args args = new createUser_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createUser_result result = new createUser_result();
    result.success = await iface_.createUser(args.req);
    oprot.writeMessageBegin(
        new TMessage("createUser", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropUser(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropUser_args args = new dropUser_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropUser_result result = new dropUser_result();
    result.success = await iface_.dropUser(args.req);
    oprot
        .writeMessageBegin(new TMessage("dropUser", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  alterUser(int seqid, TProtocol iprot, TProtocol oprot) async {
    alterUser_args args = new alterUser_args();
    args.read(iprot);
    iprot.readMessageEnd();
    alterUser_result result = new alterUser_result();
    result.success = await iface_.alterUser(args.req);
    oprot.writeMessageBegin(
        new TMessage("alterUser", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  grantRole(int seqid, TProtocol iprot, TProtocol oprot) async {
    grantRole_args args = new grantRole_args();
    args.read(iprot);
    iprot.readMessageEnd();
    grantRole_result result = new grantRole_result();
    result.success = await iface_.grantRole(args.req);
    oprot.writeMessageBegin(
        new TMessage("grantRole", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  revokeRole(int seqid, TProtocol iprot, TProtocol oprot) async {
    revokeRole_args args = new revokeRole_args();
    args.read(iprot);
    iprot.readMessageEnd();
    revokeRole_result result = new revokeRole_result();
    result.success = await iface_.revokeRole(args.req);
    oprot.writeMessageBegin(
        new TMessage("revokeRole", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listUsers(int seqid, TProtocol iprot, TProtocol oprot) async {
    listUsers_args args = new listUsers_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listUsers_result result = new listUsers_result();
    result.success = await iface_.listUsers(args.req);
    oprot.writeMessageBegin(
        new TMessage("listUsers", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listRoles(int seqid, TProtocol iprot, TProtocol oprot) async {
    listRoles_args args = new listRoles_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listRoles_result result = new listRoles_result();
    result.success = await iface_.listRoles(args.req);
    oprot.writeMessageBegin(
        new TMessage("listRoles", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getUserRoles(int seqid, TProtocol iprot, TProtocol oprot) async {
    getUserRoles_args args = new getUserRoles_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getUserRoles_result result = new getUserRoles_result();
    result.success = await iface_.getUserRoles(args.req);
    oprot.writeMessageBegin(
        new TMessage("getUserRoles", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  changePassword(int seqid, TProtocol iprot, TProtocol oprot) async {
    changePassword_args args = new changePassword_args();
    args.read(iprot);
    iprot.readMessageEnd();
    changePassword_result result = new changePassword_result();
    result.success = await iface_.changePassword(args.req);
    oprot.writeMessageBegin(
        new TMessage("changePassword", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  heartBeat(int seqid, TProtocol iprot, TProtocol oprot) async {
    heartBeat_args args = new heartBeat_args();
    args.read(iprot);
    iprot.readMessageEnd();
    heartBeat_result result = new heartBeat_result();
    result.success = await iface_.heartBeat(args.req);
    oprot.writeMessageBegin(
        new TMessage("heartBeat", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  agentHeartbeat(int seqid, TProtocol iprot, TProtocol oprot) async {
    agentHeartbeat_args args = new agentHeartbeat_args();
    args.read(iprot);
    iprot.readMessageEnd();
    agentHeartbeat_result result = new agentHeartbeat_result();
    result.success = await iface_.agentHeartbeat(args.req);
    oprot.writeMessageBegin(
        new TMessage("agentHeartbeat", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  regConfig(int seqid, TProtocol iprot, TProtocol oprot) async {
    regConfig_args args = new regConfig_args();
    args.read(iprot);
    iprot.readMessageEnd();
    regConfig_result result = new regConfig_result();
    result.success = await iface_.regConfig(args.req);
    oprot.writeMessageBegin(
        new TMessage("regConfig", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getConfig(int seqid, TProtocol iprot, TProtocol oprot) async {
    getConfig_args args = new getConfig_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getConfig_result result = new getConfig_result();
    result.success = await iface_.getConfig(args.req);
    oprot.writeMessageBegin(
        new TMessage("getConfig", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  setConfig(int seqid, TProtocol iprot, TProtocol oprot) async {
    setConfig_args args = new setConfig_args();
    args.read(iprot);
    iprot.readMessageEnd();
    setConfig_result result = new setConfig_result();
    result.success = await iface_.setConfig(args.req);
    oprot.writeMessageBegin(
        new TMessage("setConfig", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listConfigs(int seqid, TProtocol iprot, TProtocol oprot) async {
    listConfigs_args args = new listConfigs_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listConfigs_result result = new listConfigs_result();
    result.success = await iface_.listConfigs(args.req);
    oprot.writeMessageBegin(
        new TMessage("listConfigs", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createSnapshot(int seqid, TProtocol iprot, TProtocol oprot) async {
    createSnapshot_args args = new createSnapshot_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createSnapshot_result result = new createSnapshot_result();
    result.success = await iface_.createSnapshot(args.req);
    oprot.writeMessageBegin(
        new TMessage("createSnapshot", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropSnapshot(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropSnapshot_args args = new dropSnapshot_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropSnapshot_result result = new dropSnapshot_result();
    result.success = await iface_.dropSnapshot(args.req);
    oprot.writeMessageBegin(
        new TMessage("dropSnapshot", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listSnapshots(int seqid, TProtocol iprot, TProtocol oprot) async {
    listSnapshots_args args = new listSnapshots_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listSnapshots_result result = new listSnapshots_result();
    result.success = await iface_.listSnapshots(args.req);
    oprot.writeMessageBegin(
        new TMessage("listSnapshots", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  runAdminJob(int seqid, TProtocol iprot, TProtocol oprot) async {
    runAdminJob_args args = new runAdminJob_args();
    args.read(iprot);
    iprot.readMessageEnd();
    runAdminJob_result result = new runAdminJob_result();
    result.success = await iface_.runAdminJob(args.req);
    oprot.writeMessageBegin(
        new TMessage("runAdminJob", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  mergeZone(int seqid, TProtocol iprot, TProtocol oprot) async {
    mergeZone_args args = new mergeZone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    mergeZone_result result = new mergeZone_result();
    result.success = await iface_.mergeZone(args.req);
    oprot.writeMessageBegin(
        new TMessage("mergeZone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropZone(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropZone_args args = new dropZone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropZone_result result = new dropZone_result();
    result.success = await iface_.dropZone(args.req);
    oprot
        .writeMessageBegin(new TMessage("dropZone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  divideZone(int seqid, TProtocol iprot, TProtocol oprot) async {
    divideZone_args args = new divideZone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    divideZone_result result = new divideZone_result();
    result.success = await iface_.divideZone(args.req);
    oprot.writeMessageBegin(
        new TMessage("divideZone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  renameZone(int seqid, TProtocol iprot, TProtocol oprot) async {
    renameZone_args args = new renameZone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    renameZone_result result = new renameZone_result();
    result.success = await iface_.renameZone(args.req);
    oprot.writeMessageBegin(
        new TMessage("renameZone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getZone(int seqid, TProtocol iprot, TProtocol oprot) async {
    getZone_args args = new getZone_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getZone_result result = new getZone_result();
    result.success = await iface_.getZone(args.req);
    oprot.writeMessageBegin(new TMessage("getZone", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listZones(int seqid, TProtocol iprot, TProtocol oprot) async {
    listZones_args args = new listZones_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listZones_result result = new listZones_result();
    result.success = await iface_.listZones(args.req);
    oprot.writeMessageBegin(
        new TMessage("listZones", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  addListener(int seqid, TProtocol iprot, TProtocol oprot) async {
    addListener_args args = new addListener_args();
    args.read(iprot);
    iprot.readMessageEnd();
    addListener_result result = new addListener_result();
    result.success = await iface_.addListener(args.req);
    oprot.writeMessageBegin(
        new TMessage("addListener", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  removeListener(int seqid, TProtocol iprot, TProtocol oprot) async {
    removeListener_args args = new removeListener_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeListener_result result = new removeListener_result();
    result.success = await iface_.removeListener(args.req);
    oprot.writeMessageBegin(
        new TMessage("removeListener", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listListener(int seqid, TProtocol iprot, TProtocol oprot) async {
    listListener_args args = new listListener_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listListener_result result = new listListener_result();
    result.success = await iface_.listListener(args.req);
    oprot.writeMessageBegin(
        new TMessage("listListener", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getStats(int seqid, TProtocol iprot, TProtocol oprot) async {
    getStats_args args = new getStats_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getStats_result result = new getStats_result();
    result.success = await iface_.getStats(args.req);
    oprot
        .writeMessageBegin(new TMessage("getStats", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  signInService(int seqid, TProtocol iprot, TProtocol oprot) async {
    signInService_args args = new signInService_args();
    args.read(iprot);
    iprot.readMessageEnd();
    signInService_result result = new signInService_result();
    result.success = await iface_.signInService(args.req);
    oprot.writeMessageBegin(
        new TMessage("signInService", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  signOutService(int seqid, TProtocol iprot, TProtocol oprot) async {
    signOutService_args args = new signOutService_args();
    args.read(iprot);
    iprot.readMessageEnd();
    signOutService_result result = new signOutService_result();
    result.success = await iface_.signOutService(args.req);
    oprot.writeMessageBegin(
        new TMessage("signOutService", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listServiceClients(int seqid, TProtocol iprot, TProtocol oprot) async {
    listServiceClients_args args = new listServiceClients_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listServiceClients_result result = new listServiceClients_result();
    result.success = await iface_.listServiceClients(args.req);
    oprot.writeMessageBegin(
        new TMessage("listServiceClients", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createFTIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    createFTIndex_args args = new createFTIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createFTIndex_result result = new createFTIndex_result();
    result.success = await iface_.createFTIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("createFTIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  dropFTIndex(int seqid, TProtocol iprot, TProtocol oprot) async {
    dropFTIndex_args args = new dropFTIndex_args();
    args.read(iprot);
    iprot.readMessageEnd();
    dropFTIndex_result result = new dropFTIndex_result();
    result.success = await iface_.dropFTIndex(args.req);
    oprot.writeMessageBegin(
        new TMessage("dropFTIndex", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listFTIndexes(int seqid, TProtocol iprot, TProtocol oprot) async {
    listFTIndexes_args args = new listFTIndexes_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listFTIndexes_result result = new listFTIndexes_result();
    result.success = await iface_.listFTIndexes(args.req);
    oprot.writeMessageBegin(
        new TMessage("listFTIndexes", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createSession(int seqid, TProtocol iprot, TProtocol oprot) async {
    createSession_args args = new createSession_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createSession_result result = new createSession_result();
    result.success = await iface_.createSession(args.req);
    oprot.writeMessageBegin(
        new TMessage("createSession", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  updateSessions(int seqid, TProtocol iprot, TProtocol oprot) async {
    updateSessions_args args = new updateSessions_args();
    args.read(iprot);
    iprot.readMessageEnd();
    updateSessions_result result = new updateSessions_result();
    result.success = await iface_.updateSessions(args.req);
    oprot.writeMessageBegin(
        new TMessage("updateSessions", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listSessions(int seqid, TProtocol iprot, TProtocol oprot) async {
    listSessions_args args = new listSessions_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listSessions_result result = new listSessions_result();
    result.success = await iface_.listSessions(args.req);
    oprot.writeMessageBegin(
        new TMessage("listSessions", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getSession(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSession_args args = new getSession_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSession_result result = new getSession_result();
    result.success = await iface_.getSession(args.req);
    oprot.writeMessageBegin(
        new TMessage("getSession", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  removeSession(int seqid, TProtocol iprot, TProtocol oprot) async {
    removeSession_args args = new removeSession_args();
    args.read(iprot);
    iprot.readMessageEnd();
    removeSession_result result = new removeSession_result();
    result.success = await iface_.removeSession(args.req);
    oprot.writeMessageBegin(
        new TMessage("removeSession", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  killQuery(int seqid, TProtocol iprot, TProtocol oprot) async {
    killQuery_args args = new killQuery_args();
    args.read(iprot);
    iprot.readMessageEnd();
    killQuery_result result = new killQuery_result();
    result.success = await iface_.killQuery(args.req);
    oprot.writeMessageBegin(
        new TMessage("killQuery", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  reportTaskFinish(int seqid, TProtocol iprot, TProtocol oprot) async {
    reportTaskFinish_args args = new reportTaskFinish_args();
    args.read(iprot);
    iprot.readMessageEnd();
    reportTaskFinish_result result = new reportTaskFinish_result();
    result.success = await iface_.reportTaskFinish(args.req);
    oprot.writeMessageBegin(
        new TMessage("reportTaskFinish", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  createBackup(int seqid, TProtocol iprot, TProtocol oprot) async {
    createBackup_args args = new createBackup_args();
    args.read(iprot);
    iprot.readMessageEnd();
    createBackup_result result = new createBackup_result();
    result.success = await iface_.createBackup(args.req);
    oprot.writeMessageBegin(
        new TMessage("createBackup", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  restoreMeta(int seqid, TProtocol iprot, TProtocol oprot) async {
    restoreMeta_args args = new restoreMeta_args();
    args.read(iprot);
    iprot.readMessageEnd();
    restoreMeta_result result = new restoreMeta_result();
    result.success = await iface_.restoreMeta(args.req);
    oprot.writeMessageBegin(
        new TMessage("restoreMeta", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  listCluster(int seqid, TProtocol iprot, TProtocol oprot) async {
    listCluster_args args = new listCluster_args();
    args.read(iprot);
    iprot.readMessageEnd();
    listCluster_result result = new listCluster_result();
    result.success = await iface_.listCluster(args.req);
    oprot.writeMessageBegin(
        new TMessage("listCluster", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getMetaDirInfo(int seqid, TProtocol iprot, TProtocol oprot) async {
    getMetaDirInfo_args args = new getMetaDirInfo_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getMetaDirInfo_result result = new getMetaDirInfo_result();
    result.success = await iface_.getMetaDirInfo(args.req);
    oprot.writeMessageBegin(
        new TMessage("getMetaDirInfo", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  verifyClientVersion(int seqid, TProtocol iprot, TProtocol oprot) async {
    verifyClientVersion_args args = new verifyClientVersion_args();
    args.read(iprot);
    iprot.readMessageEnd();
    verifyClientVersion_result result = new verifyClientVersion_result();
    result.success = await iface_.verifyClientVersion(args.req);
    oprot.writeMessageBegin(
        new TMessage("verifyClientVersion", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  saveGraphVersion(int seqid, TProtocol iprot, TProtocol oprot) async {
    saveGraphVersion_args args = new saveGraphVersion_args();
    args.read(iprot);
    iprot.readMessageEnd();
    saveGraphVersion_result result = new saveGraphVersion_result();
    result.success = await iface_.saveGraphVersion(args.req);
    oprot.writeMessageBegin(
        new TMessage("saveGraphVersion", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }

  getSegmentId(int seqid, TProtocol iprot, TProtocol oprot) async {
    getSegmentId_args args = new getSegmentId_args();
    args.read(iprot);
    iprot.readMessageEnd();
    getSegmentId_result result = new getSegmentId_result();
    result.success = await iface_.getSegmentId(args.req);
    oprot.writeMessageBegin(
        new TMessage("getSegmentId", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.trans_.flush();
  }
}

class createSpace_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSpace_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateSpaceReq? _req;
  static const int REQ = 1;

  createSpace_args() {}

  // req
  CreateSpaceReq? get req => this._req;

  set req(CreateSpaceReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateSpaceReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateSpaceReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSpace_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createSpace_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSpace_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createSpace_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSpace_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropSpace_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropSpace_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropSpaceReq? _req;
  static const int REQ = 1;

  dropSpace_args() {}

  // req
  DropSpaceReq? get req => this._req;

  set req(DropSpaceReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropSpaceReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropSpaceReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropSpace_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropSpace_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropSpace_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropSpace_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropSpace_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class clearSpace_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clearSpace_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ClearSpaceReq? _req;
  static const int REQ = 1;

  clearSpace_args() {}

  // req
  ClearSpaceReq? get req => this._req;

  set req(ClearSpaceReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ClearSpaceReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ClearSpaceReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clearSpace_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class clearSpace_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clearSpace_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  clearSpace_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clearSpace_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getSpace_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSpace_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetSpaceReq? _req;
  static const int REQ = 1;

  getSpace_args() {}

  // req
  GetSpaceReq? get req => this._req;

  set req(GetSpaceReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetSpaceReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetSpaceReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSpace_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getSpace_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSpace_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetSpaceResp? _success;
  static const int SUCCESS = 0;

  getSpace_result() {}

  // success
  GetSpaceResp? get success => this._success;

  set success(GetSpaceResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetSpaceResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetSpaceResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSpace_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listSpaces_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listSpaces_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListSpacesReq? _req;
  static const int REQ = 1;

  listSpaces_args() {}

  // req
  ListSpacesReq? get req => this._req;

  set req(ListSpacesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListSpacesReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListSpacesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listSpaces_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listSpaces_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listSpaces_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListSpacesResp? _success;
  static const int SUCCESS = 0;

  listSpaces_result() {}

  // success
  ListSpacesResp? get success => this._success;

  set success(ListSpacesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListSpacesResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListSpacesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listSpaces_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterSpace_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterSpace_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AlterSpaceReq? _req;
  static const int REQ = 1;

  alterSpace_args() {}

  // req
  AlterSpaceReq? get req => this._req;

  set req(AlterSpaceReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AlterSpaceReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AlterSpaceReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterSpace_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterSpace_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterSpace_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  alterSpace_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterSpace_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createSpaceAs_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSpaceAs_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateSpaceAsReq? _req;
  static const int REQ = 1;

  createSpaceAs_args() {}

  // req
  CreateSpaceAsReq? get req => this._req;

  set req(CreateSpaceAsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateSpaceAsReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateSpaceAsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSpaceAs_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createSpaceAs_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSpaceAs_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createSpaceAs_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSpaceAs_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createTag_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createTag_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateTagReq? _req;
  static const int REQ = 1;

  createTag_args() {}

  // req
  CreateTagReq? get req => this._req;

  set req(CreateTagReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateTagReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateTagReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createTag_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createTag_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createTag_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createTag_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createTag_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterTag_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterTag_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AlterTagReq? _req;
  static const int REQ = 1;

  alterTag_args() {}

  // req
  AlterTagReq? get req => this._req;

  set req(AlterTagReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AlterTagReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AlterTagReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterTag_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterTag_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterTag_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  alterTag_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterTag_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropTag_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropTag_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropTagReq? _req;
  static const int REQ = 1;

  dropTag_args() {}

  // req
  DropTagReq? get req => this._req;

  set req(DropTagReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropTagReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropTagReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropTag_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropTag_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropTag_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropTag_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropTag_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getTag_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getTag_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetTagReq? _req;
  static const int REQ = 1;

  getTag_args() {}

  // req
  GetTagReq? get req => this._req;

  set req(GetTagReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetTagReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetTagReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getTag_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getTag_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getTag_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetTagResp? _success;
  static const int SUCCESS = 0;

  getTag_result() {}

  // success
  GetTagResp? get success => this._success;

  set success(GetTagResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetTagResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetTagResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getTag_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listTags_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listTags_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListTagsReq? _req;
  static const int REQ = 1;

  listTags_args() {}

  // req
  ListTagsReq? get req => this._req;

  set req(ListTagsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListTagsReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListTagsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listTags_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listTags_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listTags_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListTagsResp? _success;
  static const int SUCCESS = 0;

  listTags_result() {}

  // success
  ListTagsResp? get success => this._success;

  set success(ListTagsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListTagsResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListTagsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listTags_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createEdge_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createEdge_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateEdgeReq? _req;
  static const int REQ = 1;

  createEdge_args() {}

  // req
  CreateEdgeReq? get req => this._req;

  set req(CreateEdgeReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateEdgeReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateEdgeReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createEdge_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createEdge_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createEdge_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createEdge_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createEdge_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterEdge_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterEdge_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AlterEdgeReq? _req;
  static const int REQ = 1;

  alterEdge_args() {}

  // req
  AlterEdgeReq? get req => this._req;

  set req(AlterEdgeReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AlterEdgeReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AlterEdgeReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterEdge_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterEdge_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterEdge_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  alterEdge_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterEdge_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropEdge_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropEdge_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropEdgeReq? _req;
  static const int REQ = 1;

  dropEdge_args() {}

  // req
  DropEdgeReq? get req => this._req;

  set req(DropEdgeReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropEdgeReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropEdgeReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropEdge_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropEdge_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropEdge_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropEdge_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropEdge_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getEdge_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getEdge_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetEdgeReq? _req;
  static const int REQ = 1;

  getEdge_args() {}

  // req
  GetEdgeReq? get req => this._req;

  set req(GetEdgeReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetEdgeReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetEdgeReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getEdge_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getEdge_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getEdge_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetEdgeResp? _success;
  static const int SUCCESS = 0;

  getEdge_result() {}

  // success
  GetEdgeResp? get success => this._success;

  set success(GetEdgeResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetEdgeResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetEdgeResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getEdge_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listEdges_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listEdges_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListEdgesReq? _req;
  static const int REQ = 1;

  listEdges_args() {}

  // req
  ListEdgesReq? get req => this._req;

  set req(ListEdgesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListEdgesReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListEdgesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listEdges_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listEdges_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listEdges_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListEdgesResp? _success;
  static const int SUCCESS = 0;

  listEdges_result() {}

  // success
  ListEdgesResp? get success => this._success;

  set success(ListEdgesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListEdgesResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListEdgesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listEdges_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class addHosts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addHosts_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AddHostsReq? _req;
  static const int REQ = 1;

  addHosts_args() {}

  // req
  AddHostsReq? get req => this._req;

  set req(AddHostsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AddHostsReq?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AddHostsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addHosts_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class addHosts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addHosts_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  addHosts_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp?;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addHosts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class addHostsIntoZone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addHostsIntoZone_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AddHostsIntoZoneReq? _req;
  static const int REQ = 1;

  addHostsIntoZone_args() {}

  // req
  AddHostsIntoZoneReq? get req => this._req;

  set req(AddHostsIntoZoneReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AddHostsIntoZoneReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AddHostsIntoZoneReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addHostsIntoZone_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class addHostsIntoZone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addHostsIntoZone_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  addHostsIntoZone_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addHostsIntoZone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropHosts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropHosts_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropHostsReq? _req;
  static const int REQ = 1;

  dropHosts_args() {}

  // req
  DropHostsReq? get req => this._req;

  set req(DropHostsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropHostsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropHostsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropHosts_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropHosts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropHosts_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropHosts_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropHosts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listHosts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listHosts_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListHostsReq? _req;
  static const int REQ = 1;

  listHosts_args() {}

  // req
  ListHostsReq? get req => this._req;

  set req(ListHostsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListHostsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListHostsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listHosts_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listHosts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listHosts_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListHostsResp? _success;
  static const int SUCCESS = 0;

  listHosts_result() {}

  // success
  ListHostsResp? get success => this._success;

  set success(ListHostsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListHostsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListHostsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listHosts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getPartsAlloc_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPartsAlloc_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetPartsAllocReq? _req;
  static const int REQ = 1;

  getPartsAlloc_args() {}

  // req
  GetPartsAllocReq? get req => this._req;

  set req(GetPartsAllocReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetPartsAllocReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetPartsAllocReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPartsAlloc_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getPartsAlloc_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getPartsAlloc_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetPartsAllocResp? _success;
  static const int SUCCESS = 0;

  getPartsAlloc_result() {}

  // success
  GetPartsAllocResp? get success => this._success;

  set success(GetPartsAllocResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetPartsAllocResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetPartsAllocResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getPartsAlloc_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listParts_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listParts_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListPartsReq? _req;
  static const int REQ = 1;

  listParts_args() {}

  // req
  ListPartsReq? get req => this._req;

  set req(ListPartsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListPartsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListPartsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listParts_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listParts_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listParts_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListPartsResp? _success;
  static const int SUCCESS = 0;

  listParts_result() {}

  // success
  ListPartsResp? get success => this._success;

  set success(ListPartsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListPartsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListPartsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listParts_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getWorkerId_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getWorkerId_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetWorkerIdReq? _req;
  static const int REQ = 1;

  getWorkerId_args() {}

  // req
  GetWorkerIdReq? get req => this._req;

  set req(GetWorkerIdReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetWorkerIdReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetWorkerIdReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getWorkerId_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getWorkerId_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getWorkerId_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetWorkerIdResp? _success;
  static const int SUCCESS = 0;

  getWorkerId_result() {}

  // success
  GetWorkerIdResp? get success => this._success;

  set success(GetWorkerIdResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetWorkerIdResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetWorkerIdResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getWorkerId_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createTagIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createTagIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateTagIndexReq? _req;
  static const int REQ = 1;

  createTagIndex_args() {}

  // req
  CreateTagIndexReq? get req => this._req;

  set req(CreateTagIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateTagIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateTagIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createTagIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createTagIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createTagIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createTagIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createTagIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropTagIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropTagIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropTagIndexReq? _req;
  static const int REQ = 1;

  dropTagIndex_args() {}

  // req
  DropTagIndexReq? get req => this._req;

  set req(DropTagIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropTagIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropTagIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropTagIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropTagIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropTagIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropTagIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropTagIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getTagIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getTagIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetTagIndexReq? _req;
  static const int REQ = 1;

  getTagIndex_args() {}

  // req
  GetTagIndexReq? get req => this._req;

  set req(GetTagIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetTagIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetTagIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getTagIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getTagIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getTagIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetTagIndexResp? _success;
  static const int SUCCESS = 0;

  getTagIndex_result() {}

  // success
  GetTagIndexResp? get success => this._success;

  set success(GetTagIndexResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetTagIndexResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetTagIndexResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getTagIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listTagIndexes_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listTagIndexes_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListTagIndexesReq? _req;
  static const int REQ = 1;

  listTagIndexes_args() {}

  // req
  ListTagIndexesReq? get req => this._req;

  set req(ListTagIndexesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListTagIndexesReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListTagIndexesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listTagIndexes_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listTagIndexes_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listTagIndexes_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListTagIndexesResp? _success;
  static const int SUCCESS = 0;

  listTagIndexes_result() {}

  // success
  ListTagIndexesResp? get success => this._success;

  set success(ListTagIndexesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListTagIndexesResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListTagIndexesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listTagIndexes_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class rebuildTagIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rebuildTagIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RebuildIndexReq? _req;
  static const int REQ = 1;

  rebuildTagIndex_args() {}

  // req
  RebuildIndexReq? get req => this._req;

  set req(RebuildIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RebuildIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RebuildIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rebuildTagIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class rebuildTagIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rebuildTagIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  rebuildTagIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rebuildTagIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listTagIndexStatus_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listTagIndexStatus_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListIndexStatusReq? _req;
  static const int REQ = 1;

  listTagIndexStatus_args() {}

  // req
  ListIndexStatusReq? get req => this._req;

  set req(ListIndexStatusReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListIndexStatusReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListIndexStatusReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listTagIndexStatus_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listTagIndexStatus_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listTagIndexStatus_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListIndexStatusResp? _success;
  static const int SUCCESS = 0;

  listTagIndexStatus_result() {}

  // success
  ListIndexStatusResp? get success => this._success;

  set success(ListIndexStatusResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListIndexStatusResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListIndexStatusResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listTagIndexStatus_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createEdgeIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createEdgeIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateEdgeIndexReq? _req;
  static const int REQ = 1;

  createEdgeIndex_args() {}

  // req
  CreateEdgeIndexReq? get req => this._req;

  set req(CreateEdgeIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateEdgeIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateEdgeIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createEdgeIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createEdgeIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createEdgeIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createEdgeIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createEdgeIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropEdgeIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropEdgeIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropEdgeIndexReq? _req;
  static const int REQ = 1;

  dropEdgeIndex_args() {}

  // req
  DropEdgeIndexReq? get req => this._req;

  set req(DropEdgeIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropEdgeIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropEdgeIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropEdgeIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropEdgeIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropEdgeIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropEdgeIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropEdgeIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getEdgeIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getEdgeIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetEdgeIndexReq? _req;
  static const int REQ = 1;

  getEdgeIndex_args() {}

  // req
  GetEdgeIndexReq? get req => this._req;

  set req(GetEdgeIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetEdgeIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetEdgeIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getEdgeIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getEdgeIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getEdgeIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetEdgeIndexResp? _success;
  static const int SUCCESS = 0;

  getEdgeIndex_result() {}

  // success
  GetEdgeIndexResp? get success => this._success;

  set success(GetEdgeIndexResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetEdgeIndexResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetEdgeIndexResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getEdgeIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listEdgeIndexes_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listEdgeIndexes_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListEdgeIndexesReq? _req;
  static const int REQ = 1;

  listEdgeIndexes_args() {}

  // req
  ListEdgeIndexesReq? get req => this._req;

  set req(ListEdgeIndexesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListEdgeIndexesReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListEdgeIndexesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listEdgeIndexes_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listEdgeIndexes_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listEdgeIndexes_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListEdgeIndexesResp? _success;
  static const int SUCCESS = 0;

  listEdgeIndexes_result() {}

  // success
  ListEdgeIndexesResp? get success => this._success;

  set success(ListEdgeIndexesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListEdgeIndexesResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListEdgeIndexesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listEdgeIndexes_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class rebuildEdgeIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rebuildEdgeIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RebuildIndexReq? _req;
  static const int REQ = 1;

  rebuildEdgeIndex_args() {}

  // req
  RebuildIndexReq? get req => this._req;

  set req(RebuildIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RebuildIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RebuildIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rebuildEdgeIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class rebuildEdgeIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rebuildEdgeIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  rebuildEdgeIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rebuildEdgeIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listEdgeIndexStatus_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listEdgeIndexStatus_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListIndexStatusReq? _req;
  static const int REQ = 1;

  listEdgeIndexStatus_args() {}

  // req
  ListIndexStatusReq? get req => this._req;

  set req(ListIndexStatusReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListIndexStatusReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListIndexStatusReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listEdgeIndexStatus_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listEdgeIndexStatus_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listEdgeIndexStatus_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListIndexStatusResp? _success;
  static const int SUCCESS = 0;

  listEdgeIndexStatus_result() {}

  // success
  ListIndexStatusResp? get success => this._success;

  set success(ListIndexStatusResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListIndexStatusResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListIndexStatusResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listEdgeIndexStatus_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createUser_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createUser_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateUserReq? _req;
  static const int REQ = 1;

  createUser_args() {}

  // req
  CreateUserReq? get req => this._req;

  set req(CreateUserReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateUserReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateUserReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createUser_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createUser_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createUser_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createUser_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createUser_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropUser_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropUser_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropUserReq? _req;
  static const int REQ = 1;

  dropUser_args() {}

  // req
  DropUserReq? get req => this._req;

  set req(DropUserReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropUserReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropUserReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropUser_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropUser_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropUser_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropUser_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropUser_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterUser_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterUser_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AlterUserReq? _req;
  static const int REQ = 1;

  alterUser_args() {}

  // req
  AlterUserReq? get req => this._req;

  set req(AlterUserReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AlterUserReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AlterUserReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterUser_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class alterUser_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("alterUser_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  alterUser_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("alterUser_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class grantRole_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("grantRole_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GrantRoleReq? _req;
  static const int REQ = 1;

  grantRole_args() {}

  // req
  GrantRoleReq? get req => this._req;

  set req(GrantRoleReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GrantRoleReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GrantRoleReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("grantRole_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class grantRole_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("grantRole_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  grantRole_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("grantRole_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class revokeRole_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("revokeRole_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RevokeRoleReq? _req;
  static const int REQ = 1;

  revokeRole_args() {}

  // req
  RevokeRoleReq? get req => this._req;

  set req(RevokeRoleReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RevokeRoleReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RevokeRoleReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("revokeRole_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class revokeRole_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("revokeRole_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  revokeRole_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("revokeRole_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listUsers_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listUsers_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListUsersReq? _req;
  static const int REQ = 1;

  listUsers_args() {}

  // req
  ListUsersReq? get req => this._req;

  set req(ListUsersReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListUsersReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListUsersReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listUsers_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listUsers_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listUsers_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListUsersResp? _success;
  static const int SUCCESS = 0;

  listUsers_result() {}

  // success
  ListUsersResp? get success => this._success;

  set success(ListUsersResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListUsersResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListUsersResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listUsers_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listRoles_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listRoles_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListRolesReq? _req;
  static const int REQ = 1;

  listRoles_args() {}

  // req
  ListRolesReq? get req => this._req;

  set req(ListRolesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListRolesReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListRolesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listRoles_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listRoles_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listRoles_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListRolesResp? _success;
  static const int SUCCESS = 0;

  listRoles_result() {}

  // success
  ListRolesResp? get success => this._success;

  set success(ListRolesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListRolesResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListRolesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listRoles_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getUserRoles_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserRoles_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetUserRolesReq? _req;
  static const int REQ = 1;

  getUserRoles_args() {}

  // req
  GetUserRolesReq? get req => this._req;

  set req(GetUserRolesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetUserRolesReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetUserRolesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserRoles_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getUserRoles_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getUserRoles_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListRolesResp? _success;
  static const int SUCCESS = 0;

  getUserRoles_result() {}

  // success
  ListRolesResp? get success => this._success;

  set success(ListRolesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListRolesResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListRolesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getUserRoles_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class changePassword_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("changePassword_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ChangePasswordReq? _req;
  static const int REQ = 1;

  changePassword_args() {}

  // req
  ChangePasswordReq? get req => this._req;

  set req(ChangePasswordReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ChangePasswordReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ChangePasswordReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("changePassword_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class changePassword_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("changePassword_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  changePassword_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("changePassword_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class heartBeat_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("heartBeat_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  HBReq? _req;
  static const int REQ = 1;

  heartBeat_args() {}

  // req
  HBReq? get req => this._req;

  set req(HBReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as HBReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new HBReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("heartBeat_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class heartBeat_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("heartBeat_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  HBResp? _success;
  static const int SUCCESS = 0;

  heartBeat_result() {}

  // success
  HBResp? get success => this._success;

  set success(HBResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as HBResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new HBResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("heartBeat_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class agentHeartbeat_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("agentHeartbeat_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AgentHBReq? _req;
  static const int REQ = 1;

  agentHeartbeat_args() {}

  // req
  AgentHBReq? get req => this._req;

  set req(AgentHBReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AgentHBReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AgentHBReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("agentHeartbeat_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class agentHeartbeat_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("agentHeartbeat_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  AgentHBResp? _success;
  static const int SUCCESS = 0;

  agentHeartbeat_result() {}

  // success
  AgentHBResp? get success => this._success;

  set success(AgentHBResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as AgentHBResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AgentHBResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("agentHeartbeat_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class regConfig_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("regConfig_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RegConfigReq? _req;
  static const int REQ = 1;

  regConfig_args() {}

  // req
  RegConfigReq? get req => this._req;

  set req(RegConfigReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RegConfigReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RegConfigReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("regConfig_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class regConfig_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("regConfig_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  regConfig_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("regConfig_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getConfig_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getConfig_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetConfigReq? _req;
  static const int REQ = 1;

  getConfig_args() {}

  // req
  GetConfigReq? get req => this._req;

  set req(GetConfigReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetConfigReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetConfigReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getConfig_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getConfig_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getConfig_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetConfigResp? _success;
  static const int SUCCESS = 0;

  getConfig_result() {}

  // success
  GetConfigResp? get success => this._success;

  set success(GetConfigResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetConfigResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetConfigResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getConfig_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class setConfig_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setConfig_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  SetConfigReq? _req;
  static const int REQ = 1;

  setConfig_args() {}

  // req
  SetConfigReq? get req => this._req;

  set req(SetConfigReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as SetConfigReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new SetConfigReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setConfig_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class setConfig_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("setConfig_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  setConfig_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("setConfig_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listConfigs_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listConfigs_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListConfigsReq? _req;
  static const int REQ = 1;

  listConfigs_args() {}

  // req
  ListConfigsReq? get req => this._req;

  set req(ListConfigsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListConfigsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListConfigsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listConfigs_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listConfigs_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listConfigs_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListConfigsResp? _success;
  static const int SUCCESS = 0;

  listConfigs_result() {}

  // success
  ListConfigsResp? get success => this._success;

  set success(ListConfigsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListConfigsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListConfigsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listConfigs_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createSnapshot_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSnapshot_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateSnapshotReq? _req;
  static const int REQ = 1;

  createSnapshot_args() {}

  // req
  CreateSnapshotReq? get req => this._req;

  set req(CreateSnapshotReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateSnapshotReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateSnapshotReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSnapshot_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createSnapshot_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSnapshot_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createSnapshot_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSnapshot_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropSnapshot_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropSnapshot_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropSnapshotReq? _req;
  static const int REQ = 1;

  dropSnapshot_args() {}

  // req
  DropSnapshotReq? get req => this._req;

  set req(DropSnapshotReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropSnapshotReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropSnapshotReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropSnapshot_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropSnapshot_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropSnapshot_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropSnapshot_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropSnapshot_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listSnapshots_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listSnapshots_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListSnapshotsReq? _req;
  static const int REQ = 1;

  listSnapshots_args() {}

  // req
  ListSnapshotsReq? get req => this._req;

  set req(ListSnapshotsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListSnapshotsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListSnapshotsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listSnapshots_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listSnapshots_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listSnapshots_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListSnapshotsResp? _success;
  static const int SUCCESS = 0;

  listSnapshots_result() {}

  // success
  ListSnapshotsResp? get success => this._success;

  set success(ListSnapshotsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListSnapshotsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListSnapshotsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listSnapshots_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class runAdminJob_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("runAdminJob_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AdminJobReq? _req;
  static const int REQ = 1;

  runAdminJob_args() {}

  // req
  AdminJobReq? get req => this._req;

  set req(AdminJobReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AdminJobReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AdminJobReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("runAdminJob_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class runAdminJob_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("runAdminJob_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  AdminJobResp? _success;
  static const int SUCCESS = 0;

  runAdminJob_result() {}

  // success
  AdminJobResp? get success => this._success;

  set success(AdminJobResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as AdminJobResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AdminJobResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("runAdminJob_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class mergeZone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("mergeZone_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  MergeZoneReq? _req;
  static const int REQ = 1;

  mergeZone_args() {}

  // req
  MergeZoneReq? get req => this._req;

  set req(MergeZoneReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as MergeZoneReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new MergeZoneReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("mergeZone_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class mergeZone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("mergeZone_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  mergeZone_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("mergeZone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropZone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropZone_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropZoneReq? _req;
  static const int REQ = 1;

  dropZone_args() {}

  // req
  DropZoneReq? get req => this._req;

  set req(DropZoneReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropZoneReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropZoneReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropZone_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropZone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropZone_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropZone_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropZone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class divideZone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("divideZone_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DivideZoneReq? _req;
  static const int REQ = 1;

  divideZone_args() {}

  // req
  DivideZoneReq? get req => this._req;

  set req(DivideZoneReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DivideZoneReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DivideZoneReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("divideZone_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class divideZone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("divideZone_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  divideZone_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("divideZone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class renameZone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("renameZone_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RenameZoneReq? _req;
  static const int REQ = 1;

  renameZone_args() {}

  // req
  RenameZoneReq? get req => this._req;

  set req(RenameZoneReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RenameZoneReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RenameZoneReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("renameZone_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class renameZone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("renameZone_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  renameZone_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("renameZone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getZone_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getZone_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetZoneReq? _req;
  static const int REQ = 1;

  getZone_args() {}

  // req
  GetZoneReq? get req => this._req;

  set req(GetZoneReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetZoneReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetZoneReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getZone_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getZone_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getZone_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetZoneResp? _success;
  static const int SUCCESS = 0;

  getZone_result() {}

  // success
  GetZoneResp? get success => this._success;

  set success(GetZoneResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetZoneResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetZoneResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getZone_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listZones_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listZones_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListZonesReq? _req;
  static const int REQ = 1;

  listZones_args() {}

  // req
  ListZonesReq? get req => this._req;

  set req(ListZonesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListZonesReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListZonesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listZones_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listZones_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listZones_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListZonesResp? _success;
  static const int SUCCESS = 0;

  listZones_result() {}

  // success
  ListZonesResp? get success => this._success;

  set success(ListZonesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListZonesResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListZonesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listZones_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class addListener_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addListener_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  AddListenerReq? _req;
  static const int REQ = 1;

  addListener_args() {}

  // req
  AddListenerReq? get req => this._req;

  set req(AddListenerReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as AddListenerReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new AddListenerReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addListener_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class addListener_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("addListener_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  addListener_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("addListener_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class removeListener_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeListener_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RemoveListenerReq? _req;
  static const int REQ = 1;

  removeListener_args() {}

  // req
  RemoveListenerReq? get req => this._req;

  set req(RemoveListenerReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RemoveListenerReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RemoveListenerReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeListener_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class removeListener_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeListener_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  removeListener_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeListener_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listListener_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listListener_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListListenerReq? _req;
  static const int REQ = 1;

  listListener_args() {}

  // req
  ListListenerReq? get req => this._req;

  set req(ListListenerReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListListenerReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListListenerReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listListener_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listListener_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listListener_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListListenerResp? _success;
  static const int SUCCESS = 0;

  listListener_result() {}

  // success
  ListListenerResp? get success => this._success;

  set success(ListListenerResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListListenerResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListListenerResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listListener_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getStats_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getStats_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetStatsReq? _req;
  static const int REQ = 1;

  getStats_args() {}

  // req
  GetStatsReq? get req => this._req;

  set req(GetStatsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetStatsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetStatsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getStats_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getStats_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getStats_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetStatsResp? _success;
  static const int SUCCESS = 0;

  getStats_result() {}

  // success
  GetStatsResp? get success => this._success;

  set success(GetStatsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetStatsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetStatsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getStats_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class signInService_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("signInService_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  SignInServiceReq? _req;
  static const int REQ = 1;

  signInService_args() {}

  // req
  SignInServiceReq? get req => this._req;

  set req(SignInServiceReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as SignInServiceReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new SignInServiceReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("signInService_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class signInService_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("signInService_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  signInService_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("signInService_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class signOutService_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("signOutService_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  SignOutServiceReq? _req;
  static const int REQ = 1;

  signOutService_args() {}

  // req
  SignOutServiceReq? get req => this._req;

  set req(SignOutServiceReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as SignOutServiceReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new SignOutServiceReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("signOutService_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class signOutService_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("signOutService_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  signOutService_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("signOutService_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listServiceClients_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listServiceClients_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListServiceClientsReq? _req;
  static const int REQ = 1;

  listServiceClients_args() {}

  // req
  ListServiceClientsReq? get req => this._req;

  set req(ListServiceClientsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListServiceClientsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListServiceClientsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listServiceClients_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listServiceClients_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listServiceClients_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListServiceClientsResp? _success;
  static const int SUCCESS = 0;

  listServiceClients_result() {}

  // success
  ListServiceClientsResp? get success => this._success;

  set success(ListServiceClientsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListServiceClientsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListServiceClientsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listServiceClients_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createFTIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createFTIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateFTIndexReq? _req;
  static const int REQ = 1;

  createFTIndex_args() {}

  // req
  CreateFTIndexReq? get req => this._req;

  set req(CreateFTIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateFTIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateFTIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createFTIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createFTIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createFTIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  createFTIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createFTIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropFTIndex_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropFTIndex_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  DropFTIndexReq? _req;
  static const int REQ = 1;

  dropFTIndex_args() {}

  // req
  DropFTIndexReq? get req => this._req;

  set req(DropFTIndexReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as DropFTIndexReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new DropFTIndexReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropFTIndex_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class dropFTIndex_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("dropFTIndex_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  dropFTIndex_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("dropFTIndex_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listFTIndexes_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listFTIndexes_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListFTIndexesReq? _req;
  static const int REQ = 1;

  listFTIndexes_args() {}

  // req
  ListFTIndexesReq? get req => this._req;

  set req(ListFTIndexesReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListFTIndexesReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListFTIndexesReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listFTIndexes_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listFTIndexes_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listFTIndexes_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListFTIndexesResp? _success;
  static const int SUCCESS = 0;

  listFTIndexes_result() {}

  // success
  ListFTIndexesResp? get success => this._success;

  set success(ListFTIndexesResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListFTIndexesResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListFTIndexesResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listFTIndexes_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createSession_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSession_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateSessionReq? _req;
  static const int REQ = 1;

  createSession_args() {}

  // req
  CreateSessionReq? get req => this._req;

  set req(CreateSessionReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateSessionReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateSessionReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSession_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createSession_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createSession_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  CreateSessionResp? _success;
  static const int SUCCESS = 0;

  createSession_result() {}

  // success
  CreateSessionResp? get success => this._success;

  set success(CreateSessionResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as CreateSessionResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new CreateSessionResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createSession_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class updateSessions_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSessions_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  UpdateSessionsReq? _req;
  static const int REQ = 1;

  updateSessions_args() {}

  // req
  UpdateSessionsReq? get req => this._req;

  set req(UpdateSessionsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as UpdateSessionsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new UpdateSessionsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSessions_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class updateSessions_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("updateSessions_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  UpdateSessionsResp? _success;
  static const int SUCCESS = 0;

  updateSessions_result() {}

  // success
  UpdateSessionsResp? get success => this._success;

  set success(UpdateSessionsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as UpdateSessionsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new UpdateSessionsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("updateSessions_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listSessions_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listSessions_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListSessionsReq? _req;
  static const int REQ = 1;

  listSessions_args() {}

  // req
  ListSessionsReq? get req => this._req;

  set req(ListSessionsReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListSessionsReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListSessionsReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listSessions_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listSessions_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listSessions_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListSessionsResp? _success;
  static const int SUCCESS = 0;

  listSessions_result() {}

  // success
  ListSessionsResp? get success => this._success;

  set success(ListSessionsResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListSessionsResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListSessionsResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listSessions_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getSession_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSession_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetSessionReq? _req;
  static const int REQ = 1;

  getSession_args() {}

  // req
  GetSessionReq? get req => this._req;

  set req(GetSessionReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetSessionReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetSessionReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSession_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getSession_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSession_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetSessionResp? _success;
  static const int SUCCESS = 0;

  getSession_result() {}

  // success
  GetSessionResp? get success => this._success;

  set success(GetSessionResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetSessionResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetSessionResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSession_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class removeSession_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeSession_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RemoveSessionReq? _req;
  static const int REQ = 1;

  removeSession_args() {}

  // req
  RemoveSessionReq? get req => this._req;

  set req(RemoveSessionReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RemoveSessionReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RemoveSessionReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeSession_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class removeSession_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("removeSession_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  RemoveSessionResp? _success;
  static const int SUCCESS = 0;

  removeSession_result() {}

  // success
  RemoveSessionResp? get success => this._success;

  set success(RemoveSessionResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as RemoveSessionResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new RemoveSessionResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("removeSession_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class killQuery_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("killQuery_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  KillQueryReq? _req;
  static const int REQ = 1;

  killQuery_args() {}

  // req
  KillQueryReq? get req => this._req;

  set req(KillQueryReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as KillQueryReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new KillQueryReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("killQuery_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class killQuery_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("killQuery_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  killQuery_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("killQuery_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class reportTaskFinish_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportTaskFinish_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ReportTaskReq? _req;
  static const int REQ = 1;

  reportTaskFinish_args() {}

  // req
  ReportTaskReq? get req => this._req;

  set req(ReportTaskReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ReportTaskReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ReportTaskReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportTaskFinish_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class reportTaskFinish_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("reportTaskFinish_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ExecResp? _success;
  static const int SUCCESS = 0;

  reportTaskFinish_result() {}

  // success
  ExecResp? get success => this._success;

  set success(ExecResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ExecResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ExecResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("reportTaskFinish_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createBackup_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createBackup_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  CreateBackupReq? _req;
  static const int REQ = 1;

  createBackup_args() {}

  // req
  CreateBackupReq? get req => this._req;

  set req(CreateBackupReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as CreateBackupReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new CreateBackupReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createBackup_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class createBackup_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("createBackup_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  CreateBackupResp? _success;
  static const int SUCCESS = 0;

  createBackup_result() {}

  // success
  CreateBackupResp? get success => this._success;

  set success(CreateBackupResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as CreateBackupResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new CreateBackupResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("createBackup_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class restoreMeta_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("restoreMeta_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  RestoreMetaReq? _req;
  static const int REQ = 1;

  restoreMeta_args() {}

  // req
  RestoreMetaReq? get req => this._req;

  set req(RestoreMetaReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as RestoreMetaReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new RestoreMetaReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("restoreMeta_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class restoreMeta_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("restoreMeta_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  RestoreMetaResp? _success;
  static const int SUCCESS = 0;

  restoreMeta_result() {}

  // success
  RestoreMetaResp? get success => this._success;

  set success(RestoreMetaResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as RestoreMetaResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new RestoreMetaResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("restoreMeta_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listCluster_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listCluster_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  ListClusterInfoReq? _req;
  static const int REQ = 1;

  listCluster_args() {}

  // req
  ListClusterInfoReq? get req => this._req;

  set req(ListClusterInfoReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as ListClusterInfoReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new ListClusterInfoReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listCluster_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class listCluster_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("listCluster_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  ListClusterInfoResp? _success;
  static const int SUCCESS = 0;

  listCluster_result() {}

  // success
  ListClusterInfoResp? get success => this._success;

  set success(ListClusterInfoResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as ListClusterInfoResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ListClusterInfoResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("listCluster_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getMetaDirInfo_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMetaDirInfo_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetMetaDirInfoReq? _req;
  static const int REQ = 1;

  getMetaDirInfo_args() {}

  // req
  GetMetaDirInfoReq? get req => this._req;

  set req(GetMetaDirInfoReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetMetaDirInfoReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetMetaDirInfoReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMetaDirInfo_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getMetaDirInfo_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getMetaDirInfo_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetMetaDirInfoResp? _success;
  static const int SUCCESS = 0;

  getMetaDirInfo_result() {}

  // success
  GetMetaDirInfoResp? get success => this._success;

  set success(GetMetaDirInfoResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetMetaDirInfoResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetMetaDirInfoResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getMetaDirInfo_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class verifyClientVersion_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyClientVersion_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  VerifyClientVersionReq? _req;
  static const int REQ = 1;

  verifyClientVersion_args() {}

  // req
  VerifyClientVersionReq? get req => this._req;

  set req(VerifyClientVersionReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as VerifyClientVersionReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new VerifyClientVersionReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyClientVersion_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class verifyClientVersion_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("verifyClientVersion_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  VerifyClientVersionResp? _success;
  static const int SUCCESS = 0;

  verifyClientVersion_result() {}

  // success
  VerifyClientVersionResp? get success => this._success;

  set success(VerifyClientVersionResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as VerifyClientVersionResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new VerifyClientVersionResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("verifyClientVersion_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class saveGraphVersion_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("saveGraphVersion_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  SaveGraphVersionReq? _req;
  static const int REQ = 1;

  saveGraphVersion_args() {}

  // req
  SaveGraphVersionReq? get req => this._req;

  set req(SaveGraphVersionReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as SaveGraphVersionReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new SaveGraphVersionReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("saveGraphVersion_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class saveGraphVersion_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("saveGraphVersion_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  SaveGraphVersionResp? _success;
  static const int SUCCESS = 0;

  saveGraphVersion_result() {}

  // success
  SaveGraphVersionResp? get success => this._success;

  set success(SaveGraphVersionResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as SaveGraphVersionResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SaveGraphVersionResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("saveGraphVersion_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getSegmentId_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSegmentId_args");
  static final TField _REQ_FIELD_DESC = new TField("req", TType.STRUCT, 1);

  GetSegmentIdReq? _req;
  static const int REQ = 1;

  getSegmentId_args() {}

  // req
  GetSegmentIdReq? get req => this._req;

  set req(GetSegmentIdReq? req) {
    this._req = req;
  }

  bool isSetReq() => this.req != null;

  unsetReq() {
    this.req = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case REQ:
        return this.req;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case REQ:
        if (value == null) {
          unsetReq();
        } else {
          this.req = value as GetSegmentIdReq;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case REQ:
        return isSetReq();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case REQ:
          if (field.type == TType.STRUCT) {
            this.req = new GetSegmentIdReq();
            this.req?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.req != null) {
      oprot.writeFieldBegin(_REQ_FIELD_DESC);
      this.req?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSegmentId_args(");

    ret.write("req:");
    if (this.req == null) {
      ret.write("null");
    } else {
      ret.write(this.req);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}

class getSegmentId_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("getSegmentId_result");
  static final TField _SUCCESS_FIELD_DESC =
      new TField("success", TType.STRUCT, 0);

  GetSegmentIdResp? _success;
  static const int SUCCESS = 0;

  getSegmentId_result() {}

  // success
  GetSegmentIdResp? get success => this._success;

  set success(GetSegmentIdResp? success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object? value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value as GetSegmentIdResp;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new GetSegmentIdResp();
            this.success?.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success?.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("getSegmentId_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }
}
